/* 2025-04-12 
  <함수> 
- 값에 의한 호출(Call by Value) : 실 매개변수(아규먼트)의 값을 *복사*해서 형식 매개변수(파라미터)에 전달   
	파라미터에 전달되는 값은 복사된 데이터이기 때문에 파라미터 값이 변해도 원본 아규먼트 값은 변하지 않음.
	즉, 기억공간 자체도 다르므로 서로 다른 변수로 취급됨.
- 참조에 의한 호출(Call by reference) : 실 매개변수(아규먼트)와 형식 매개변수(파라미터)가 *같은 기억공간*을 사용.
	같은 기억공간을 사용하기 때문에, 파라미터 값을 변경하면 원본 아규먼트 값도 함께 변경됨.
	즉, 같은 변수로 취급됨.
	C언어에서는 지원하지 않음, 하지만 포인터를 이용하여 참조의 의한 호출과 유사한 기능을 구현 할 수 있음.
    포인터 사용 -> *변수의 주소를 전달*하여 원본 값을 수정 가능함.   
*/

/*
리턴타입 함수명(파라미터 선언){ // 파라미터 타입과 아규먼트 타입이 서로 일치해야 함
	함수 호출 시 실행할 명령어;
	return 반환값; //리턴타입과 반환값 타입이 서로 일치해야한다
}
*/
#include <stdio.h>

// 함수 정의 : main() 함수보다 위에 정의해야 컴파일러가 이 함수의 존재를 알 수 있음

// 아규먼트 값을 오름차순으로 정렬하는 함수
// 값에 의한 호출(전달 받은 값은 복사된 값)이므로, 함수 내에서 a와 b가 바뀌더라도 원본 변수에는 영향 없음
void sort_asc(int a, int b) {
	if (a > b) { // a가 b보다 크면 두 값을 서로 바꿈(늘 a가 작은 값이 오게끔 함)
		int temp = a;
		a = b;
		b = temp;
	}
	// 하지만 이 변경은 함수 내부에서만 일어나고,
	// main 함수의 아규먼트로 넣은 원본 변수 a, b에는 전혀 영향을 주지 않음
}

// 포인터 사용(변수의 주소를 전달하여 원본 값을 수정함), 참조에 의한 호출과 유사
void sort_asc_reference(int *a, int *b) { //C언어는 오버로딩 지원하지 않음
	if (*a > *b) { //주의! a > b는 주소 비교이기 때문에 포인터가 가리키는 값끼리의 비교해야함
		int temp = *a;
		*a = *b;
		*b = temp;
	}
	// 하지만 이 변경은 함수 내부에서만 일어나고,
	// main 함수의 아규먼트로 넣은 원본 변수 a, b에는 전혀 영향을 주지 않음
}


int main(void) { // void : main 함수가 어떤 아규먼트(인자)도 받지 않음을 명시하는 표현
	// (표준 C에서는 int main(void) 또는 int main(int argc, char *argv[])가 권장됨)
	
	// 일일이 중복된 코드를 사용하면 수정하기가 귀찮아진다(유지보수의 어려움)
	printf("===============");
	printf("\n");
	printf(" 프로그램 결과 ");
	printf("\n");
	printf("===============");
	printf("\n");
	printf("  %d + %d = %d  ",5, 3, 5 + 3);
	printf("\n");
	printf("===============");

	printf("\n\n");

	//for문으로 구분선 출력 코드 작성, 그래도 아직은 수정시 귀찮음
	for (int i = 0;i < 15;i++) {
		printf("="); // = 15개 나란히 한줄에 출력됨
	}
	printf("\n");
	printf(" 프로그램 결과 ");
	printf("\n");
	for (int i = 0; i < 15; i++) {
		printf("="); // = 15개 나란히 한줄에 출력됨
	}
	printf("\n");
	printf("  %d + %d = %d  ", 5, 3, 5 + 3);
	printf("\n");
	for (int i = 0; i < 15; i++) {
		printf("="); // = 15개 나란히 한줄에 출력됨
	}
	
	printf("\n\n");

	// 함수 사용 - 자주 사용되는 기능은 함수를 만들어 사용하면 편하다

	// 값에 의한 호출(Call by Value)
	// 아규먼트의 값을 복사해서 파라미터에 전달하므로,
	// 함수 내부에서 파라미터 값이 변해도 원본 변수는 변하지 않음
	int a = 7, b = 5;

	// a가 b보다 크면 두 값을 서로 바꾸기
	/* 
	if (a > b) { 		
		int temp = a;
		a = b;
		b = temp;
	} 
	*/

	// 값에 의한 호출 : 아규먼트의 값을 복사하여 전달
	sort_asc(a, b);  
	printf("%d <= %d \n\n", a, b); // 7 <= 5
	// → 원본 아규먼트 값은 변하지 않음

	//포인터 사용 : 아규먼트로 변수의 주소값을 전달하여 원본 값 변경
	sort_asc_reference(&a, &b);
	printf("%d <= %d \n\n", a, b); // 5 <= 7
	// → 원본 값 변함

	return 0;
}


